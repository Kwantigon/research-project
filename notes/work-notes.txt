Co když nechám uživatele psát jen na začátku. Další zprávy už pouze klikáním. Nemá možnost psát / upravovat navrhované zprávy.

Jaké typy zpráv budu mít? Měl bych je více oddělit nebo stačí UserMessage a SystemMessage?

Na prvotní query systém odpoví:
- Negativní odpověď: uživatel se zeptal na něco úplně mimo.
- Positivní odpověď:
	1. FE zobrazí Sparql query.
		Tady potřebuje od BE čistě jen textovou odpověď, která obsahuje Sparql query.
	2. FE řekne uživateli, že může kliknout na nějaká slova, aby si zobrazil summary.
		Potřebuje vědět jaká slova. Ideálně pozici v původní větě a kolik znaků (nebo slov).

Nejsem si jistý, jestli v kódu musím rozlišovat typy systémových zpráv. Pro začátek to budu rozlišovat a pokud se ukáže, že není potřeba, tak to upravím.

V property summary bude jednodušší, když vyjmenuju všechny properties, které by uživatele mohlo zajímat.
Uživatel pak může vybírat v tom seznamu.
Je to jednodušší než nechat uživatele klikat přímo do summary.

Když si uživatel zvolí, že chce použít nějaké property pro expanzi, tak jakou metodou to poslat na server? A na jaký endpoint?

Idea je, že na serveru si stavím tu další otázku uživatele, ale ještě ji necommitnu do konverzace. Když si uživatel zvolí propertu, tak se přidá do té další otázky. Když uživatel pošle samotnou zprávu, kterou jsme spolu sestavili, tak BE opravdu přidá tu otázku do konverzace.
- Jak zpracovat tu další otázku? Určitě ne stejným způsobem jako první otázka.
- Přidat si ty zvolené properties do podstruktury, kterou stavím na back endu.
- Nechat si přeložit tu podstrukturu do Sparqlu.
- Říct LLM, aby mi dalo nějaké rozumné další properties?
FE: POST question-preview + 1 property.
BE: Přidá property do substructure preview + řekne LLM, aby lexikalizoval.
FE: GET question-preview.
BE: Vrátí lexikalizaci.
FE: PUT question-preview + 1 property?
Request na question-preview by možná vždycky měl obsahovat všechny properties, které uživatel tam chce. Tím umožním i to, že když uživatel chce odebrat property, tak stačí poslat PUT request s příslušnými parametry a BE vytvoří správné preview?
- Takže správný HTTP verb bude PUT.
FE si musí držet seznam properties, které si uživatel vybral.

Back end si udržuje stav konverzace.
2 možnosti, jak uživatel může zadat svůj follow-up otázku.
- Ručně napíše.
- Vybírá si properties a pak potvrdí.
- To by trochu zjednodušilo zpracování na back endu, když přijde zpráva.
- Pokud uživatel potvrdil, na back endu můžu jen potvrdit question preview.
- Pokud uživatel zadal ručně otázku, možná budu muset zpracovat jako první dotaz.

Konkrétní data v databázi nemám, ale možná bych mohl použít LLM, abych mohl doplnit do dotazu to, co uživatel chce.
Například chce: Tournaments that have taken place this year so far in which there are participants *from Vietnam*.
- Já dokážu vyznačit to, že dotaz se bude týkat tournament a player a country.
- Tak teď nějakým způsobem říct LLM, kam by měl uživatel doplnit specifické hodnoty, které chce ve svém dotazu mít - např. Vietnam.

Když v RequestHandleru budu zpracovávat rovnou všechny operace, tak bude dělat moc různých věcí.
Přidám další abstrakci: IDataSpecificationService, IConversationService atd.
RequestHandler bude jen volat operace na těchto servisách.

RequestHandler bude mít zodpovědnost:
- Zkontrolovat příchozí payload.
- Volat metody na dalších I...Service ve správném pořadí.
- Sestavit výslednou HTTP odpověď a vrátit.
- Bude vždy vracet IResults.
- Objekt, který se má vracet bude v tom results body.
Jen přemýšlím, jestli bych měl vytvořit třídu, která bude vracet ty objekty.
Chtěl bych, aby na první pohled bylo vidět, co vrací která metoda.
- Ale když všechno bude vracet IResults, tak to není vidět.

Eventually budu chtít použít nějaký ExceptionHandler, aby transformoval vyjímky na HTTP odpovědi.
- Zatím se soustředím na to, abych měl funkční back end.

*29/03/2025*
Nakreslil jsem si trochu pořádněji architekturu.
Popsal jsem boxy architektury ve specifikaci.

To do: Vytvořit jeden úplně kompletní příklad. Dovést to až do konce. Ne jenom říct, že se to bude opakovat.
- Jeden příklad, kde rozšíření dotazu budou jen selecty.
- Jeden příklad, kde rozšíření dotazu je i nějaké filtrování.

*20/04/2025*
Jak píšu tu mock konverzaci, tak se mi zdá, že pořád bude lepší mít jen seznam namapovaných slov. Potom ty související itemy zobrazit až když uživatel si rozklikne to slovo.
- A nebo to nechat jako seznam, ale vhodně odrazit.
- Když item patří třeba do tournaments, tak vylistovat hned pod tournaments a ještě odrazit.
- JAJA to zní dobře.
Nevýhoda tohoto přístupu je, že se musím zastavit po nějakém stupni zanoření. Když to zobrazím v separátním oknu, tak teoreticky uživatel může klikat a jít do jakékoliv hloubky.

Major části, které musím nastudovat a implementovat.
1. Co poslat do LLM a jak promptovat, abych získal výstup, který potřebuju.
	3.a) Musím si vytvořit nějaký Dataspecer package. Nebo použít již existující.
	3.b) Musím získat přístup na náš LLM server - napsat do chatu.
2. Co si vytáhnout z toho Dataspecer package pro zpracování.
	- Vyřeším, pokud udělám krok 1.
3. Jak stáhnout Dataspecer package v kódu.
	- Poradit se se Štěpánem.
4. Přidat databázi.
	4.a) Podívat se na Entity Framework guide.
	4.b) Rozběhnout Sqlite nebo Postgres.
5. Nastudovat, jak převést data specification substructure na Sparql query (pro implementaci Sparql translation service).
6. Implementovat front end.

26/04/2025
Když si exportuju specifikaci z Dataspeceru, tak tam je .owl.ttl soubor, což je RDF.

Když mám data jako RDF, tak to je vždycky node, šipka a další node ne? Takže můžu teoreticky reprezentovat tady ty 2 věci v kódu?
- Určitě můžu uložit typ class.
- Určitě můžu uložit typ relationship.
- Myslím si, že typ property můžu taky.
Když se zeptám na summary RDF, tak mi LLAMA popíše class, property a relationship. Takže tady ty 3 věci budou items.

Když řeknu "summarize class ...", tak to popíše to, co je napsaný v tom RDF. Já si pod "summarize" představuju spíše kousek textu, který je srozumitelný pro netechnického člověka.

Please summarize the class "barrier-free access" in a few sentences so that a non-technical person can understand it.
The "Barrier-Free Access" class refers to information about how easily people with disabilities can access and use a particular location, such as a building or tourist destination. It describes the
accessibility features of the location from the user's point of view. This class is used to provide details about the accessibility of a place, which can be helpful for people who need to plan their
visits accordingly.
- Toto už je trochu lepší, ale je dost možné, že si bude domýšlet. Ale to asi nevadí, protože bych chtěl, aby z kontextu té datové specifikace udělal to shrnutí.

Data specification:
- Určitě si uložím RDF string.
- Uložím si items. Ale pokud je datová specifikace velká, tak asi nemůžu uložit všechno ne?
- Ještě bych si mohl uložit další věci jako datové struktury atd. Prostě kontext kolem toho.
Data specification item:
- Uložím si typ (class, property, relationship).
- Summary (některé si už můžu předem vygenerovat).

Otázky:
- Jak bych měl ukládat ten OWL soubor? Jako text v databázi pod data specification?
- Co použít jako ID itemu?

*02/05/2025*
Pořád řeším, jak rozdělit zpracování endpointů.
- Mít jeden controller.
- Nebo mít různé controllery pro každé endpointy.
Do specifikace jsem napsal, že request handler deleguje práci do ostatních modulů.

Myslím si, že dává smysl, že Program.cs mapuje endpoint. Nějaký controller bude volat metody na conversation service a případně jiných servisech. Pak ten výsledek přetransformuje do vhodné HTTP formy.
- Např. na některé věci bude volat IConversationService. Ale pak vrátí jen 201_Created nebo něco takového.
- To nedává smysl vracet z IConversationService.

Co vše musím udělat, abych měl funkční back end?
- Zpracovat Dataspecer package (DSL do OWL a pak uložit jako string).
- Přidat Entity Framework.
- Implementovat komunikaci s Ollama.
- Přidat potřebné metody do interface servisů v core.

Mapuju endpointy a podle těch endpointů definuju metody, které musejí servisy podporovat.

Přemýšlím, co si uložit pod datovou specifikaci. Jestli všechny její třídy a property.
- To může teoreticky být hodně.
- Stejně vždycky dávám tu specifikaci jako RDF do LLM.
- Takže si jen uložím ten OWL.
Jako podstrukturu si uložím prostě seznam itemů.
- K tomu ještě třeba suggested message.
